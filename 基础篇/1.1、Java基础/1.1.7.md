# String、StringBuilder 以及 StringBuffer
## 一、你了解 String 类吗？
&emsp;&emsp;想要了解一个类，最好的办法就是阅读这个类的源码。  
&emsp;&emsp;java.lang.String 类的源码：
```java
public final class String implements java.io.Serializable, Comparable<String>, CharSequence {
    /** The value is used for character storage. */
    private final char value[];
 
    /** The offset is the first index of the storage that is used. */
    private final int offset;
 
    /** The count is the number of characters in the String. */
    private final int count;
 
    /** Cache the hash code for the string */
    private int hash; // Default to 0
 
    /** use serialVersionUID from JDK 1.0.2 for interoperability */
    private static final long serialVersionUID = -6849794470754667710L;

    ...
}
```
&emsp;&emsp;从源码中可以发现：  
&emsp;&emsp;1. String 类是 final 类，也即意味着 String 类不能被继承，并且它的成员方法都默认为 final 方法。在 Java 中，被 final 修饰的类是不允许被继承的，并且该类中的成员方法都默认为final方法。在早期的JVM实现版本中，被 final 修饰的方法会被转为内嵌调用以提升执行效率。而从Java SE5/6开始，就渐渐摈弃这种方式了。因此在现在的 Java SE 版本中，不需要考虑用 final 去提升方法调用效率。只有在确定不想让该方法被覆盖时，才将方法设置为 final。  
&emsp;&emsp;2. 上面列举出了 String 类中所有的成员属性，从上面可以看出String 类其实是通过 char 数组来保存字符串的。  
&emsp;&emsp;String类的一些方法实现：  
```java
public String substring(int beginIndex, int endIndex) {
    if (beginIndex < 0) {
        throw new StringIndexOutOfBoundsException(beginIndex);
    }
    if (endIndex > count) {
        throw new StringIndexOutOfBoundsException(endIndex);
    }
    if (beginIndex > endIndex) {
        throw new StringIndexOutOfBoundsException(endIndex - beginIndex);
    }
    return ((beginIndex == 0) && (endIndex == count)) ? this : new String(offset + beginIndex, endIndex - beginIndex, value);
}
 
public String concat(String str) {
    int otherLen = str.length();
    if (otherLen == 0) {
        return this;
    }
    char buf[] = new char[count + otherLen];
    getChars(0, count, buf, 0);
    str.getChars(0, otherLen, buf, count);
    return new String(0, count + otherLen, buf);
}
 
public String replace(char oldChar, char newChar) {
    if (oldChar != newChar) {
        int len = value.length;
        int i = -1;
        char[] val = value; 

        while (++i < len) {
            if (val[i] == oldChar) {
                break;
            }
        }
        if (i < len) {
            char buf[] = new char[len];
            for (int j = 0; j < i; j++) {
                buf[j] = val[j];
            }
            while (i < len) {
                char c = val[i];
                buf[i] = (c == oldChar) ? newChar : c;
                i++;
            }
            return new String(buf, true);
        }
    }
    return this;
}
```
&emsp;&emsp;从上面的三个方法可以看出，无论是 sub 操作、concat 操作还是 replace 操作都不是在原有的字符串上进行的，而是重新生成了一个新的字符串对象。也就是说进行这些操作后，最原始的字符串并没有被改变。  
&emsp;&emsp;**总之，对 String 对象的任何操作都不会影响原对象。**
## 二、深入理解 String、StringBuffer、StringBuilder
### 2.1 String s = "one"; 和 String s = new String("one"); 的区别
```java
public class Main {
    public static void main(String[] args) {
        String str1 = "hello world";
        String str2 = new String("hello world");
        String str3 = "hello world";
        String str4 = new String("hello world");

        System.out.println(str1 == str2);//false
        System.out.println(str1 == str3);//true
        System.out.println(str2 == str4);//false
    }
}
```
&emsp;&emsp;在 class 文件中有一部分来存储编译期间生成的字面常量以及符号引用，这部分叫做 class 文件常量池，在运行期间对应着方法区的运行时常量池。  
&emsp;&emsp;因此在上述代码中，String str1 = "hello world";和 String str3 = "hello world"; 都在编译期间生成了字面常量和符号引用，运行期间字面常量"hello world"被存储在运行时常量池（当然只保存了一份）。通过这种方式来将 String 对象跟引用绑定的话，JVM 执行引擎会先在运行时常量池查找是否存在相同的字面常量，如果存在，则直接将引用指向已经存在的字面常量；否则在运行时常量池开辟一个空间来存储该字面常量，并将引用指向该字面常量。  
&emsp;&emsp;众所周知，通过 new 关键字来生成对象是在堆区进行的，而在堆区进行对象生成的过程是不会去检测该对象是否已经存在的。因此通过new来创建对象，创建出的一定是不同的对象，即使字符串的内容是相同的。
## 三、不同场景下三个类的性能测试