# String、StringBuilder 以及 StringBuffer
## 一、你了解 String 类吗？
&emsp;&emsp;想要了解一个类，最好的办法就是阅读这个类的源码。  
&emsp;&emsp;java.lang.String 类的源码：
```java
public final class String implements java.io.Serializable, Comparable<String>, CharSequence {
    /** The value is used for character storage. */
    private final char value[];
 
    /** The offset is the first index of the storage that is used. */
    private final int offset;
 
    /** The count is the number of characters in the String. */
    private final int count;
 
    /** Cache the hash code for the string */
    private int hash; // Default to 0
 
    /** use serialVersionUID from JDK 1.0.2 for interoperability */
    private static final long serialVersionUID = -6849794470754667710L;

    ...
}
```
&emsp;&emsp;从源码中可以发现：  
&emsp;&emsp;1. String 类是 final 类，也即意味着 String 类不能被继承，并且它的成员方法都默认为 final 方法。在 Java 中，被 final 修饰的类是不允许被继承的，并且该类中的成员方法都默认为final方法。在早期的JVM实现版本中，被 final 修饰的方法会被转为内嵌调用以提升执行效率。而从Java SE5/6开始，就渐渐摈弃这种方式了。因此在现在的 Java SE 版本中，不需要考虑用 final 去提升方法调用效率。只有在确定不想让该方法被覆盖时，才将方法设置为 final。  
&emsp;&emsp;2. 上面列举出了 String 类中所有的成员属性，从上面可以看出String 类其实是通过 char 数组来保存字符串的。  
&emsp;&emsp;String类的一些方法实现：  
```java
public String substring(int beginIndex, int endIndex) {
    if (beginIndex < 0) {
        throw new StringIndexOutOfBoundsException(beginIndex);
    }
    if (endIndex > count) {
        throw new StringIndexOutOfBoundsException(endIndex);
    }
    if (beginIndex > endIndex) {
        throw new StringIndexOutOfBoundsException(endIndex - beginIndex);
    }
    return ((beginIndex == 0) && (endIndex == count)) ? 
            this : new String(offset + beginIndex, endIndex - beginIndex, value);
}
 
public String concat(String str) {
    int otherLen = str.length();
    if (otherLen == 0) {
        return this;
    }
    char buf[] = new char[count + otherLen];
    getChars(0, count, buf, 0);
    str.getChars(0, otherLen, buf, count);
    return new String(0, count + otherLen, buf);
}
 
public String replace(char oldChar, char newChar) {
    if (oldChar != newChar) {
        int len = value.length;
        int i = -1;
        char[] val = value; 

        while (++i < len) {
            if (val[i] == oldChar) {
                break;
            }
        }
        if (i < len) {
            char buf[] = new char[len];
            for (int j = 0; j < i; j++) {
                buf[j] = val[j];
            }
            while (i < len) {
                char c = val[i];
                buf[i] = (c == oldChar) ? newChar : c;
                i++;
            }
            return new String(buf, true);
        }
    }
    return this;
}
```
&emsp;&emsp;从上面的三个方法可以看出，无论是 sub 操作、concat 操作还是 replace 操作都不是在原有的字符串上进行的，而是重新生成了一个新的字符串对象。也就是说进行这些操作后，最原始的字符串并没有被改变。  
&emsp;&emsp;**总之，对 String 对象的任何操作都不会影响原对象。**
## 二、深入理解 String、StringBuffer、StringBuilder
### 2.1 String s = "one"; 和 String s = new String("one"); 的区别
```java
public class Main {
    public static void main(String[] args) {
        String str1 = "hello world";
        String str2 = new String("hello world");
        String str3 = "hello world";
        String str4 = new String("hello world");

        System.out.println(str1 == str2);//false
        System.out.println(str1 == str3);//true
        System.out.println(str2 == str4);//false
    }
}
```
&emsp;&emsp;在 class 文件中有一部分来存储编译期间生成的字面常量以及符号引用，这部分叫做 class 文件常量池，在运行期间对应着方法区的运行时常量池。  
&emsp;&emsp;因此在上述代码中，String str1 = "hello world";和 String str3 = "hello world"; 都在编译期间生成了字面常量和符号引用，运行期间字面常量"hello world"被存储在运行时常量池（当然只保存了一份）。通过这种方式来将 String 对象跟引用绑定的话，JVM 执行引擎会先在运行时常量池查找是否存在相同的字面常量，如果存在，则直接将引用指向已经存在的字面常量；否则在运行时常量池开辟一个空间来存储该字面常量，并将引用指向该字面常量。  
&emsp;&emsp;众所周知，通过 new 关键字来生成对象是在堆区进行的，而在堆区进行对象生成的过程是不会去检测该对象是否已经存在的。因此通过new来创建对象，创建出的一定是不同的对象，即使字符串的内容是相同的。
### 2.2 String、StringBuffer 以及 StringBuilder 的区别
&emsp;&emsp;既然在 Java 中已经存在了 String 类，那为什么还需要 StringBuilder 类和 StringBuffer 类呢？  
&emsp;&emsp;那么看下面这段代码：
```java
public class App {
    public static void main(String[] args) {
        String string = "";
        for (int i = 0; i < 10000; i++) {
            string += "hello";
        }
    }
}
```
&emsp;&emsp;这句 string += "hello";的过程相当于将原有的 string 变量指向的对象内容取出与"hello"作字符串相加操作再存进另一个新的 String 对象当中，再让 string 变量指向新生成的对象。如果大家还有疑问可以反编译其字节码文件便清楚了：
```java
public class App {
  // compiled from: App.java
  // access flags 0x1
  public <init>()V
   L0
    LINENUMBER 1 L0
    ALOAD 0
    INVOKESPECIAL java/lang/Object.<init> ()V
    RETURN
   L1
    LOCALVARIABLE this LApp; L0 L1 0
    MAXSTACK = 1
    MAXLOCALS = 1

  // access flags 0x9
  public static main([Ljava/lang/String;)V
   L0
    LINENUMBER 3 L0
    LDC ""
    ASTORE 1
   L1
    LINENUMBER 4 L1
    ICONST_0
    ISTORE 2
   L2
   FRAME APPEND [java/lang/String I]
    ILOAD 2
    SIPUSH 10000
    IF_ICMPGE L3
   L4
    LINENUMBER 5 L4
    NEW java/lang/StringBuilder
    DUP
    INVOKESPECIAL java/lang/StringBuilder.<init> ()V
    ALOAD 1
    INVOKEVIRTUAL java/lang/StringBuilder.append (Ljava/lang/String;)Ljava/lang/StringBuilder;
    LDC "hello"
    INVOKEVIRTUAL java/lang/StringBuilder.append (Ljava/lang/String;)Ljava/lang/StringBuilder;
    INVOKEVIRTUAL java/lang/StringBuilder.toString ()Ljava/lang/String;
    ASTORE 1
   L5
    LINENUMBER 4 L5
    IINC 2 1
    GOTO L2
   L3
    LINENUMBER 7 L3
   FRAME CHOP 1
    RETURN
   L6
    LOCALVARIABLE i I L2 L3 2
    LOCALVARIABLE args [Ljava/lang/String; L0 L6 0
    LOCALVARIABLE string Ljava/lang/String; L1 L6 1
    MAXSTACK = 2
    MAXLOCALS = 3
}
```
&emsp;&emsp;从这段反编译出的字节码文件可以很清楚地看出：在整个循环的执行过程中，每次循环会 new 出一个 StringBuilder 对象，然后进行 append 操作，最后通过toString 方法返回 String 对象。也就是说这个循环执行完毕 new 出了 10000 个对象，试想一下，如果这些对象没有被回收，会造成多大的内存资源浪费。从上面还可以看出：string+="hello"的操作事实上会自动被JVM优化成：
```java
StringBuilder str = new StringBuilder(string);
str.append("hello");
str.toString();
```
&emsp;&emsp;再看下面这段代码：
```java
public class App {
    public static void main(String[] args) {
        StringBuilder stringBuilder = new StringBuilder();
        for (int i = 0; i < 10000; i++) {
            stringBuilder.append("hello");
        }
    }
}
```
反编译字节码文件得到：
```java
public class App {
  public <init>()V
   L0
    LINENUMBER 1 L0
    ALOAD 0
    INVOKESPECIAL java/lang/Object.<init> ()V
    RETURN
   L1
    LOCALVARIABLE this LApp; L0 L1 0
    MAXSTACK = 1
    MAXLOCALS = 1

  // access flags 0x9
  public static main([Ljava/lang/String;)V
   L0
    LINENUMBER 3 L0
    NEW java/lang/StringBuilder
    DUP
    INVOKESPECIAL java/lang/StringBuilder.<init> ()V
    ASTORE 1
   L1
    LINENUMBER 4 L1
    ICONST_0
    ISTORE 2
   L2
   FRAME APPEND [java/lang/StringBuilder I]
    ILOAD 2
    SIPUSH 10000
    IF_ICMPGE L3
   L4
    LINENUMBER 5 L4
    ALOAD 1
    LDC "hello"
    INVOKEVIRTUAL java/lang/StringBuilder.append (Ljava/lang/String;)Ljava/lang/StringBuilder;
    POP
   L5
    LINENUMBER 4 L5
    IINC 2 1
    GOTO L2
   L3
    LINENUMBER 7 L3
   FRAME CHOP 1
    RETURN
   L6
    LOCALVARIABLE i I L2 L3 2
    LOCALVARIABLE args [Ljava/lang/String; L0 L6 0
    LOCALVARIABLE stringBuilder Ljava/lang/StringBuilder; L1 L6 1
    MAXSTACK = 2
    MAXLOCALS = 3
}
```
&emsp;&emsp;从这里可以明显看出，这段代码 new 操作只进行了一次，也就是说只生成了一个对象，append 操作是在原有对象的基础上进行的。因此在循环了10000次之后，这段代码所占的资源要比上面小得多。  
&emsp;&emsp;那么有人会问既然有了 StringBuilder 类，为什么还需要 StringBuffer 类？查看源代码便一目了然，事实上，StringBuilder 和 StringBuffer 类拥有的成员属性以及成员方法基本相同，区别是 StringBuffer 类的成员方法前面多了一个关键字：synchronized，不用多说，这个关键字是在多线程访问时起到安全保护作用的,也就是说StringBuffer 是线程安全的。  
&emsp;&emsp;StringBuffer 类和 StringBuilder 类中的 insert方法对比：
```java
//StringBuilder 类的 insert 方法
public StringBuilder insert(int index, char str[], int offset, int len) {
    super.insert(index, str, offset, len);
    return this;
}

//StringBuffer 类的 insert 方法
public synchronized StringBuffer insert(int index, char str[], int offset, int len) {
    super.insert(index, str, offset, len);
    return this;
}
```
## 三、不同场景下三个类的性能测试
&emsp;&emsp;从第二节我们已经看出了三个类的区别，这一小节我们来做个小测试，来测试一下三个类的性能区别：
```java
import org.junit.Test;

public class StringTest {
    private static int time = 50000;

    @Test
    public void testString() {
        String s = "";
        long begin = System.currentTimeMillis();
        for (int i = 0; i < time; i++) {
            s += "java";
        }
        long over = System.currentTimeMillis();
        System.out.println("操作" + s.getClass().getName() + "类型使用的时间为：" + (over - begin) + "毫秒");
    }

    @Test
    public void testStringBuffer() {
        StringBuffer sb = new StringBuffer();
        long begin = System.currentTimeMillis();
        for (int i = 0; i < time; i++) {
            sb.append("java");
        }
        long over = System.currentTimeMillis();
        System.out.println("操作" + sb.getClass().getName() + "类型使用的时间为：" + (over - begin) + "毫秒");
    }

    @Test
    public void testStringBuilder() {
        StringBuilder sb = new StringBuilder();
        long begin = System.currentTimeMillis();
        for (int i = 0; i < time; i++) {
            sb.append("java");
        }
        long over = System.currentTimeMillis();
        System.out.println("操作" + sb.getClass().getName() + "类型使用的时间为：" + (over - begin) + "毫秒");
    }

    @Test
    public void test1String() {
        long begin = System.currentTimeMillis();
        for (int i = 0; i < time; i++) {
            String s = "I" + "love" + "java";
        }
        long over = System.currentTimeMillis();
        System.out.println("字符串直接相加操作：" + (over - begin) + "毫秒");
    }

    @Test
    public void test2String() {
        String s1 = "I";
        String s2 = "love";
        String s3 = "java";
        long begin = System.currentTimeMillis();
        for (int i = 0; i < time; i++) {
            String s = s1 + s2 + s3;
        }
        long over = System.currentTimeMillis();
        System.out.println("字符串间接相加操作：" + (over - begin) + "毫秒");
    }
}
```
### 测试结果：
- 操作java.lang.String类型使用的时间为：4290毫秒
- 操作java.lang.StringBuilder类型使用的时间为：2毫秒
- 操作java.lang.StringBuffer类型使用的时间为：4毫秒
- 字符串直接相加操作：0毫秒
- 字符串间接相加操作：4毫秒
### 结论
1. 对于直接相加字符串，效率很高，因为在编译器便确定了它的值，也就是说形如"I"+"love"+"java"; 的字符串相加，在编译期间便被优化成了"Ilovejava"。这个可以用 javap -c命令反编译生成的 class 文件进行验证。
2. 对于间接相加（即包含字符串引用），形如s1+s2+s3; 效率要比直接相加低，因为在编译器不会对引用变量进行优化。
3. String、StringBuilder、StringBuffer三者的执行效率：  
StringBuilder > StringBuffer > String  
当然这个是相对的，不一定在所有情况下都是这样。  
比如 String str = "hello"+ "world"的效率就比 StringBuilder st  = new StringBuilder().append("hello").append("world")要高。  
因此，这三个类是各有利弊，应当根据不同的情况来进行选择使用：  
当字符串相加操作或者改动较少的情况下，建议使用 String str="hello"这种形式；  
当字符串相加操作较多的情况下，建议使用StringBuilder，如果采用了多线程，则使用StringBuffer。