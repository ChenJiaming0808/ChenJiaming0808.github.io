# final, finally, finalize 的区别
## final
&emsp;&emsp;在Java中，final可以用来修饰类、方法和变量（成员变量或局部变量）。
### 修饰类
&emsp;&emsp;当用final修饰类时，表明该类不能被其它类所继承。所以当我们需要让一个类用永远不能被继承，就可以用final去修饰，但要注意：  
&emsp;&emsp;****final类中的所有成员方法都会隐式的定义为final方法****
### 修饰方法
使用final方法的原因主要有两个：  
&emsp;&emsp;（1）防止子类重写方法  
&emsp;&emsp;（2）效率，在早期的java版本中，会将final方法转为内嵌调用。但若方法过于庞大，可能在性能上不会有多大提升。因此在最近版本中，不需要final方法进行这些优化了。  
&emsp;&emsp;**若父类中final方法的访问权限为private，将导致子类中不能直接继承该方法，因此，此时可以在子类中定义相同方法名的函数，此时不会与重写final的矛盾，而是在子类中重新地定义了新方法。**
### 修饰变量
&emsp;&emsp;**final成员变量表示常量，只能被赋值一次，赋值后其值不再改变。类似于C++中的const。**  
&emsp;&emsp;当final修饰一个基本数据类型时，表示该基本数据类型的值一旦在初始化后便不能发生变化；如果final修饰一个引用类型时，则在对其初始化之后便不能再让其指向其他对象了，但该引用所指向的对象的内容是可以发生变化的。本质上是一回事，因为引用的值是一个地址，final要求值，即地址的值不发生变化。  
&emsp;&emsp;**final修饰一个成员变量（属性），必须要显示初始化。这里有两种初始化方式，一种是在变量声明的时候初始化；第二种方法是在声明变量的时候不赋初值，但是要在这个变量所在的类的所有的构造函数中对这个变量赋初值。**  
&emsp;&emsp;当函数的参数类型声明为final时，说明该参数是只读型的。即你可以读取使用该参数，但是无法改变该参数的值。  
&emsp;&emsp;在java中，String被设计成final类，那为什么平时使用时，String的值可以被改变呢？  
&emsp;&emsp;字符串常量池是java堆内存中一个特殊的存储区域，当我们建立一个String对象时，假设常量池不存在该字符串，则创建一个，若存在则直接引用已经存在的字符串。当我们对String对象值改变的时候，例如 String a="A"; a="B" 。a是String对象的一个引用（我们这里所说的String对象其实是指字符串常量），当a=“B”执行时，并不是原本String对象("A")发生改变，而是创建一个新的对象("B")，令a引用它。
## finally
&emsp;&emsp;finally作为异常处理的一部分，它只能用在try/catch语句中，并且附带一个语句块，表示这段语句最终一定会被执行（不管有没有抛出异常），经常被用在需要释放资源的情况下。
## finalize
&emsp;&emsp;finalize()是在java.lang.Object里定义的，也就是说每一个对象都有这么个方法。这个方法在gc启动，该对象被回收的时候被调用。其实gc可以回收大部分的对象（凡是new出来的对象，gc都能搞定，一般情况下我们又不会用new以外的方式去创建对象），所以一般是不需要程序员去实现finalize的。  
&emsp;&emsp;特殊情况下，需要程序员实现finalize，当对象被回收的时候释放一些资源，比如：一个socket链接，在对象初始化时创建，整个生命周期内有效，那么就需要实现finalize，关闭这个链接。  
&emsp;&emsp;使用finalize还需要注意一个事，调用super.finalize();  
&emsp;&emsp;一个对象的finalize()方法只会被调用一次，而且finalize()被调用不意味着gc会立即回收该对象，所以有可能调用finalize()后，该对象又不需要被回收了，然后到了真正要被回收的时候，因为前面调用过一次，所以不会调用finalize()，产生问题。 所以，推荐不要使用finalize()方法，它跟析构函数不一样。